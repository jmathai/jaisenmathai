<h3>Twitter-async documentation</h3>
<ol class="article">
  <li><a href="#dependencies">Dependencies</a></li>
  <li>
    <a href="#usage_and_examples">Usage and examples</a>
    <ul>
      <li>
        <a href="#response">Accessing the response</a>
        <ul>
          <li><a href="#responseheaders">Exposing the response headers</a></li>
          <li><a href="#enumerated">A note on enumerated lists</a></li>
        </ul>
      </li>
      <li>
        <a href="#exceptions">Catching and handling exceptions</a>
        <ul>
          <li><a href="#exception_hierarchy">Exception hierarchy</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <a href="#method_based_api">Method based API</a>
    <ul>
      <li><a href="#methodnames">Understanding method names</a></li>
    </ul>
  </li>
  <li><a href="#multipart">Uploading images using multipart</a></li>
  <li><a href="#oauthcallback">Using the oauth_callback parameter</a></li>
  <li>
    <a href="#async">Efficiently using asynchronous curl</a>
    <ul>
      <li><a href="#sequence">Using the sequencer to verify asynchronous requests</a></li>
    </ul>
  </li>
  <li><a href="#create">Creating an OAuth application on Twitter</a></li>
  <li><a href="#commonerrors">Common errors</a></li>
</ol>

<h4>Getting started</h4>
<p>
Twitter-async lets you easily integrate with Twitter's REST API using OAuth.  In addition to being easy to use, it supports asynchronous calls. You can <a href="http://github.com/jmathai/twitter-async" target="_blank">download it here</a> (<a href="http://github.com/jmathai/twitter-async/zipball/master">zip</a> or <a href="http://github.com/jmathai/twitter-async/tarball/master">tar.gz</a>).
</p>
<p>
If you would like a walk-through tutorial then you can read the following blog posts.
<ul>
  <li><a href="/articles/twitter-php-oauth.html">How to quickly integrate with Twitter's OAuth API using PHP</a></li>
  <li><a href="/articles/twitter-php-sign-in.html">Letting your users sign in with Twitter using OAuth</a></li>
</ul>
</p>

<h4><a name="dependencies"></a>Dependencies</h4>
<p>
  <ol>
    <li>PHP 5.2 or higher</li>
    <li>EpiTwitter, EpiOAuth and EpiCurl (included with the repository)</li>
  </ol>
</p>

<h4><a name="usage_and_examples"></a>Usage  and examples</h4>
<p>
Some of the Twitter API endpoints require authentication while others don't.  For authenticated API calls you can provide credentials using OAuth.  Basic authentication requires that you send the username and password of the account you want to use.  OAuth let's you pass tokens, instead of passwords, to make authenticated calls.  Twitter-async makes it easy by exposing an extremely simple API.
<ul>
  <li><span class="code">get($endpoint[, $params])</span> - GET request using OAuth</li>
  <li><span class="code">post($endpoint[, $params])</span> - POST request using OAuth</li>
  <li><span class="code">delete($endpoint[, $params])</span> - DELETE request using OAuth</li>
  <li><a href="#methodnames">A method based API</a> also exists</li>
</ul>
<pre name="code" class="php">  // Calls which do not require authentication
  $twitterObj = new EpiTwitter($consumerKey, $consumerSecret, $oauthToken, $oauthSecret);
  $creds = $twitterObj->get('/account/verify_credentials.json');
  echo $creds->responseText;</pre>
</p>

<h4><a name="response"></a>Accessing the response</h4>
<p>
All calls to Twitter APIs return an object with properties.  The properties are named identical to what is in the response and dimensions of 2 or more are exposed as arrays.  For example, the following JSON response is from the <em>verify credentials</em> API.

<pre name="code" class="javascript">  {
    screen_name: "jmathai",
    name: "Jaisen Mathai",
    status: {
      text: "My last status",
      created_at: "Thu Apr 09 15:00:07 +0000 2009"
    },
  }</pre>
</P>
<p>
Each of these values can be accessed the following ways.

<pre name="code" class="php">  // Access properties directly as member variables
  $userInfo->screen_name;
  $userInfo->name;
  $userInfo->status->text;
  $userInfo->status->created_at;

  // Access properties as an array through the response property
  $userInfo->response['screen_name'];
  $userInfo->response['name'];
  $userInfo->response['status']['text'];
  $userInfo->response['status']['created_at'];</pre>
</p>
<h4><a name="responseheaders"></a>Exposing the response headers</h4>
<p>
You can access the response headers for your request by checking the <span class="code">$resp->headers</span> array.

<pre name="code" class="php">  $resp = $twitterObj->get('/search.json', array('q' => 'twitter'));
  var_dump($resp->headers);
  echo "You have {$resp->headers['X-RateLimit-Remaining']} calls remaining";</pre>
</p>

<h4><a name="enumerated"></a>A note on enumerated lists</h4>

<p>Some responses are returned as an enumerated list.  Since PHP requires that object properties start with [a-Z_] you can't use <span class="code">$resp->0->screen_name</span>.  Given the following JSON response, you can use either of the methods described below.
<pre name="code" class="php">  [
    {
        screen_name: "jmathai",
        name: "Jaisen Mathai"
        ...
    },
    {
        screen_name: "jmathai",
        name: "Jaisen Mathai"
        ...
    },
    ...
  ]</pre>

<pre name="code" class="php">  // Access the respose as an array
  $firstFollower = $resp[0]->screen_name

  // Loop over the response as an an array
  foreach($resp as $follower){
      echo $follower->screen_name;
  }</pre>
</p>

<h4><a name="exceptions"></a>Catching and handling exceptions</h4>

<p>Twitter-async throws an exception anytime the HTTP response code is not between 200 and 399.    For debugging purposes, accessing <span class="code">responseText</span> doesn't follow this pattern and will always return the raw response.  It's recommended that you catch specific exceptions in favor of the base <span class="code">Exception</span>.  Here is an example of catching an <span class="code">EpiTwitterException</span> and falling back to the base <span class="code">Exception</span>.

<p><em>NOTE: If you have set the library to operate asynchronously the exception isn't thrown until you access any of the return values from the API call.</em></p>

<pre name="code" class="php">  try{
    $twitterInfo = $twitterObj->get('/account/verify_credentials.json');
    echo $twitterInfo->screen_name;
  }catch(EpiTwitterException $e){
    echo 'We caught an EpiOAuthException';
    echo $e->getMessage();
  }catch(Exception $e){
    echo 'We caught an unexpected Exception';
    echo $e->getMessage();
  }</pre>
</p>

<h4><a name="exception_hierarchy"></a>Exception hierarchy</h4>

<p>
<ul>
  <li><span class="code">EpiTwitterException extends Exception</span> - General uncaught or unknown exceptions</li>
  <li><span class="code">EpiTwitterBadRequestException extends EpiTwitterException</span> - 400 response code</li>
  <li><span class="code">EpiTwitterNotAuthorizedException extends EpiTwitterException</span> - 401 response code</li>
  <li><span class="code">EpiTwitterForbiddenException extends EpiTwitterException</span> - 403 response code</li>
  <li><span class="code">EpiTwitterNotFoundException extends EpiTwitterException</span> - 404 response code</li>
  <li><span class="code">EpiTwitterNotAcceptableException extends EpiTwitterException</span> - 406 response code</li>
  <li><span class="code">EpiTwitterEnhanceYourCalmException extends EpiTwitterException</span> - 420 response code</li>
  <li><span class="code">EpiTwitterInternalServerException extends EpiTwitterException</span> - 500 response code</li>
  <li><span class="code">EpiTwitterBadGatewayException extends EpiTwitterException</span> - 502 response code</li>
  <li><span class="code">EpiTwitterServiceUnavailableException extends EpiTwitterException</span> - 503 response code</li>
</ul>
</p>

<h4><a name="method_based_api"></a>Method based API</h4>

<p>The <span class="code">__call</span> method handles the method based API invocations.  There's a simple naming pattern used to determine the proper method you want to call for a given API endpoint.  Let's start with the most common first example of validating a set of credentials.</p>

<p><a href="http://apiwiki.twitter.com/REST+API+Documentation#account/verifycredentials" target="_blank">Documentation on Twitter's site</a>.</p>

<pre name="code" class="php">  $twitterObj = new EpiTwitter(TWITTER_CONSUMER_KEY, TWITTER_CONSUMER_SECRET, $userToken, $userSecret);
  $userInfo = $twitterObj->get_accountVerify_credentials();
  // access keys directly
  echo "Your Twitter username is {$userInfo->screen_name}";
  // access response text
  echo $userInfo->responseText;
  // access response as an array
  var_dump($userInfo->result);</pre>

<h4><a name="methodnames"></a>Understanding method names</h4>

<p>The method based API directly maps to API endpoints.  In the example above, the method name <span class="code">get_accountVerify_credentials</span> consists of the <em>HTTP method</em> (<strong>get</strong>) and the url path (<strong>account/verify_credentials</strong>).  Simply follow these rules to determine the proper method name.
<ol>
  <li>The first part is the _HTTP method_ (in lowercase) specified by the API docs (i.e. get, post) <span class="code">get</span></li>
  <li>Follow the method with an underscore <span class="code">get_</span></li>
  <li>The second half of the method name is the URI path.  This is entirely lowercase except for when there needs to be a <strong><em>/</em></strong> (slash) which is denoted by a capital letter <span class="code">get_accountVerify_credentials</span></li>
  <li>The method takes an associative array as a list of parameters to be sent along with the request <span class="code">get_accountVerify_credentials(array('name'=>'value'))</span></li>
</ol>
</p>

<pre name="code" class="php">  /* GET -> /followers/ids.json?screen_name=yahoo */
  $twtObj->get_followersIds(array('screen_name' => 'yahoo'));

  /* POST -> /statuses/update.json?status=This+is+my+new+status */
  $twtObj->post_statusesUpdate(array('status' => 'This is my new status'));

  /* GET -> /statuses/followers/jmathai_test.json */
  $userId = ucwords(strtolower($userId));
  $method = "get_statusesFollowers{$userId}"; // $userId = jmathai_test
  $twtObj->$method();</pre>

<h4><a name="multipart"></a>Uploading images using multipart</h4>

<p>Twitter-async supports uploading images via the Twitter API <strong>using OAuth</strong>.  To specify the <em>image</em> parameter to the <span class="code">account/update_profile*image</span> endpoints you'll need to prepend the key and value with an <em>@</em>.  The path to the file must be the absolute path to the file on the server.</p>

<pre name="code" class="php">  $twitterObj->post('/account/update_profile_image.json', array('@image' => '@/tmp/myfile.jpg'));
// http://github.com/jmathai/twitter-async/issues#issue/68
// some people have issues with the image uploading and a suggested workaround is to add the  mime type
$twitterObj->post('/account/update_profile_image.json', array('@image' => '@/tmp/myfile.jpg;type=image/jpeg'));</pre>

<h4><a name="oauthcallback"></a>Using the oauth_callback parameter</h4>

<p>In the 1.0a version of the API Twitter added support for an _oauth_callback_ paramter.  This parameter allows you to programmatically specify the callback url which Twitter redirects to.  Originally, Twitter would always redirect the user back to the URL you specified in your OAuth settings.</p>

<p>To specify a different callback url you can pass in a parameter into <span class="code">getAuthenticateurl</span> or <span class="code">getAuthorizeUrl</span>.</p>

<pre name="code" class="php">  $url = $twitterObj->getAuthorizeUrl(null,array('oauth_callback' => 'http://mysite.com/custom/callback'));
  echo '<a href="'.$url.'">Authorize with Twitter</a>';</pre>

<p>Twitter associates the URL you specified with the OAuth token they give back to you.  This url works like normal and when the user visits it they will be taken to Twitter's OAuth page as normal.  Once they authorize usage of your application then Twitter will forward the user to the URL you specified.  They will include an additional parameter in the url named _oauth_verifier_.  This parameter needs to be passed in to _getAccessToken_ in order to exchange the request token for an access token.  Aside from these two additional parameters the flow is identical except you can specify the callback URL at run time.</p>

<pre name="code" class="php">  $twitterObj->setToken($_GET['oauth_token']);  
  $token = $twitterObj->getAccessToken(array('oauth_verifier' => $_GET['oauth_verifier']));
  $twitterObj->setToken($token->oauth_token, $token->oauth_token_secret);
  $twitterInfo = $twitterObj->get('/account/verify_credentials.json');
  echo $twitterInfo->screen_name;</code></pre> 

<h4><a name="async"></a>Efficiently using asynchronous curl</h4>

<p>Twitter-async was carefully written to maximize the efficiency of making HTTP web service requests.  Knowing that curl calls are expensive, we don't want to wait around idly while we could be doing other work.  This is especially true if you need to make multiple calls on a single page.  Ideally, you could fire off several requests in parallel instead of doing them one at a time.  To enable asynchronous calls you will need to call <span class="code">useAsynchronous(true)</span> on the Twitter-async object.</p>

<p>The key to using Twitter-async efficiently is to delay accessing the results for as long as possible.  Initiating the call fires off the HTTP request and immediately returns control back to you without blocking.  The call continues to work in the background until you need the results.  For the best performance it's advised to initiate the calls as early as possible and only block by accessing the results as late as possible.  The implementation details depend greatly on your framework.</p>

<pre name="code" class="php">  $twitterObj = new EpiTwitter(TWITTER_CONSUMER_KEY, TWITTER_CONSUMER_SECRET, $userToken, $userSecret);
  $twitterObj->useAsynchronous(true);
  $followers = array('user1','user2','user3','user4','user5');
  $responses = array();
  // send off the requests in parallel
  foreach($followers as $follower) {
    $responses[] = $twitterObj->post('/direct_messages/new.json', array('user' => $follower, 'text' => "Hey {$follower} what's up?"));
  }

  // now we retrieve the results and ensure that each call completes
  foreach($responses as $response) {
    echo "Direct message had an id of {$response->id}\n";
  }</code></pre>

<h4><a name="sequence"></a>Using the sequencer to verify asynchronous requests</h4>

<p>It's important to validate that your calls are truly asynchronous.  The library includes a sequencer class which displays a graph of the calls to show you how the calls are sequenced. You can look at the file <span class="code">tests/sequencerTest.php</span> for an example.</p>

<pre name="code" class="php">// To display the sequence graph you can add the following code to the bottom of your page.
echo EpiCurl::getSequence()->renderAscii();

// To run the example you can execute the sequencerTest.php file from the command line
`php sequencerTest.php`
Test sequencing diagram of api calls

(http://api.twitter.com/1/direct_messages.json ::  code=200, start=1283577305.2462, end=1283577305.5109, total=0.264562)
[========================================================================]
(http://api.twitter.com/1/users/suggestions.json ::  code=200, start=1283577305.2726, end=1283577305.3871, total=0.114419)
[         =================                                              ]
(http://api.twitter.com/1/statuses/public_timeline.json ::  code=200, start=1283577305.2731, end=1283577305.4195, total=0.146262)
[          ============================                                  ]</code></pre>

<h4><a name="create"></a>Creating an OAuth application on Twitter</h4>

<p>To start off, you'll need to "create an application":http://twitter.com/oauth_clients on Twitter.  They will give you a *_consumer key_* and a *_consumer secret_*.  Copy and paste this into your site's configuration file since you'll be needing them later.  The rest of the information is embedded in Twitter-async.</p>

<pre name="code" class="php">  define('TWITTER_CONSUMER_KEY', 'your_consumer_key');
  define('TWITTER_CONSUMER_SECRET', 'your_consumer_secret');</code></pre>

<h4><a name="commonerrors"></a>Common OAuth errors</h4>

<p>
<ol class="article">
  <li>
    Failed to validate oauth signature and token
    <ul>
      <li>Make sure your system clock is correct (<a href="http://blainegarrett.com/2009/07/14/failed-to-validate-oauth-signature-and-token-on-twitter-oauth-check-your-cloc/" target="_blank">source</a>)</li>
    </ul>
  </li>
  <li>
    Curl error - name lookup timed out.
    <ul>
      <li>Increase time out of request and connection, using the <span class="code">setTimeout()</span> method on the client.</li>
    </ul>
  </li>
  <li>
    Non ascii characters throw errors.
    <ul>
      <li>Convert the string first using <span class="code">iconv("ISO-8859-1", "UTF-8", 'Your string here')</span>. <a href="http://github.com/jmathai/twitter-async/issues/closed#issue/58" target="_blank">Related bug</a></li>
    </ul>
  </li>
</ul>
</p>

